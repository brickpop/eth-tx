module.exports = {
  compileTo,
  compileBundled,
  bundleContractFile,
  wrapContract
};

const Promise = require("bluebird");
const solc = require("solc");
var compiler = null;

var fs, path;
if (typeof window === "undefined") {
  // NODEJS ONLY
  fs = require("fs");
  path = require("path");
}

const {
  relocateErrors,
  prependFileNameToken,
  argsToOpts
} = require("./util.js");

const {
  getCurrentWeb3,
  // sendTransaction,
  sendContractTransaction,
  sendContractConstantTransaction,
  estimateContractTransactionGas,
  deployContract
} = require("./rpc.js");

// FUNCTIONS

function initialize() {
  return fetchLatestCompiler().catch(err => {
    console.log(err);
  });
}

function compileTo(entrySrcFile, destFile, opts = {}) {
  if (!fs)
    throw new Error("compileTo() is only available on NodeJS environments");

  return bundleContractFile(entrySrcFile)
    .then(src => {
      src = applyConstants(src, opts);
      return compileBundled(src);
    })
    .then(compiledContracts => {
      var output =
        "/* This is an autogenerated file. DO NOT EDIT IT MANUALLY */\n\n";
      output += "module.exports = {";

      Object.keys(compiledContracts).forEach(contractName => {
        const contract = compiledContracts[contractName];

        if (contractName[0] === ":") contractName = contractName.substr(1);
        var abi = JSON.parse(contract.interface);
        var byteCode = contract.bytecode;

        output += `\n  ${contractName}: {
    abi: ${JSON.stringify(abi)},
    byteCode: "0x${byteCode}"
  },\n`;
      });
      output += "}\n\n";

      return new Promise((resolve, reject) => {
        fs.writeFile(destFile, output, err => {
          if (err) reject(err);
          else resolve();
        });
      });
    });
}

function compileBundled(bundledSource) {
  return Promise.try(() => {
    if (compiler) return;
    return initialize();
  }).then(() => {
    var result = solc.compile(bundledSource, 1);

    if (Object.keys(result.contracts).length) {
      return result.contracts;
    } else if (result.errors && result.errors.length) {
      throw relocateErrors(bundledSource, result.errors).join("\n");
    }
    throw new Error("No output was generated");
  });
}

function bundleContractFile(file, alreadyImported = {}) {
  if (!fs)
    throw new Error(
      "bundleContractFile() is only available on NodeJS environments"
    );

  var fileSource = "";
  if (alreadyImported[file]) return "";

  alreadyImported[file] = true;

  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function(err, sourceCode) {
      if (err) return reject(err);
      fileSource = sourceCode;
      resolve();
    });
  })
    .then(() => {
      // resolve solidity import's
      var r = /^import "(.*)";/gm;
      var matches = fileSource.match(r);

      fileSource = fileSource.replace(r, "");

      if (!matches) return [];

      return Promise.map(matches, line => {
        var r = /import "(.*)";/;
        var pendingImportedFile = r.exec(line)[1];

        pendingImportedFile = path.join(
          path.dirname(file),
          pendingImportedFile
        );

        return bundleContractFile(pendingImportedFile, alreadyImported);
      });
    })
    .then(imports => {
      return (imports || []).join("") + prependFileNameToken(file) + fileSource;
    });
}

function applyConstants(src, opts) {
  Object.keys(opts).forEach(k => {
    var pattern = new RegExp("constant " + k + " = (.*);", "gm");
    var replacedText = "constant " + k + " = " + opts[k] + ";";

    // TO DO check that strings (that are not addresses) get stringified

    src = src.replace(pattern, replacedText);
  });
  return src;
}

// Create a class from a contract ABI/ByteCode

function wrapContract(abi, byteCode) {
  if (!abi)
    throw new Error("The contract's Application Binary Interface is required");
  else if (typeof byteCode == "undefined")
    throw new Error("The contract's bytecode parameter is required");

  return class WrappedContract {
    constructor(address) {
      this.$address = address;
      this.$abi = abi;
      this.$byteCode = byteCode;

      const web3 = getCurrentWeb3();
      if (web3.version[0] == "0") {
        // version 0.x.x
        this.$contract = web3.eth.contract(this.$abi).at(this.$address);
      } else {
        // newer
        this.$contract = new web3.eth.Contract(this.$abi, this.$address);
      }

      this.defineContractMethods();
    }

    // Populate contract methods
    defineContractMethods() {
      this.$abi.forEach(({ /*constant,*/ name, inputs, type }) => {
        // if (type === "constructor") return
        if (type !== "function") return;

        // TODO overloaded functions

        // Function
        const self = this;
        this[name] = (...args) => {
          var opts = argsToOpts(args, inputs);
          return {
            call: () => {
              // constant
              return sendContractConstantTransaction(
                self.$contract,
                self.$abi,
                name,
                opts
              );
            },
            send: () => {
              // transaction
              return sendContractTransaction(
                self.$contract,
                self.$abi,
                name,
                opts
              );
            },
            estimateGas: () => {
              return estimateContractTransactionGas(
                self.$contract,
                self.$abi,
                name,
                opts
              );
            }
          };
        };
      });
    }

    static new(...args) {
      const func = abi.find(func => func && func.type === "constructor");
      var constructorInputs = [];
      if (func) constructorInputs = func.inputs;

      var opts = argsToOpts(args, constructorInputs);

      opts.$abi = abi;
      opts.$byteCode = byteCode;

      return deployContract(opts).then(contract => {
        if (!contract) throw new Error("Empty contract");

        return new WrappedContract(
          (contract.options && contract.options.address) ||
            contract._address ||
            contract.address
        );
      });
    }
  };
}

function fetchLatestCompiler() {
  return new Promise((resolve, reject) => {
    solc.loadRemoteVersion("latest", function(err, solcSnapshot) {
      if (err) {
        return reject(new Error("Unable to fetch the solc compiler"));
      }
      compiler = solcSnapshot;
      resolve();
    });
  });
}
