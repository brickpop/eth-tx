module.exports = {
  bundleContracts,
  applyConstants,
  compileBundle,
  compile
};

const { handleErrorLines, prependFileNameToken } = require("./lib/util.js");

var fs, path;
if (typeof window === "undefined") {
  // NODEJS ONLY
  fs = require("fs");
  path = require("path");
}

function bundleContracts(file, alreadyImported = {}) {
  if (typeof window !== "undefined")
    throw new Error("This functionality is only available on NodeJS");

  var src;
  if (alreadyImported[file]) return "";

  alreadyImported[file] = true;

  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function(err, sourceCode) {
      if (err) return reject(err);
      src = sourceCode;
      resolve();
    });
  })
    .then(() => {
      // resolve solidity import's
      var r = /^import "(.*)";/gm;
      var matches = src.match(r);

      src = src.replace(r, "");

      if (!matches) return src;

      return Promise.map(matches, line => {
        var r = /import "(.*)";/;
        var pendingImportedFile = r.exec(line)[1];

        pendingImportedFile = path.join(
          path.dirname(file),
          pendingImportedFile
        );

        return bundleContracts(
          pendingImportedFile,
          alreadyImported
        ).then(content => {
          return prependFileNameToken(file) + content;
        });
      });
    })
    .then(imports => {
      return src + imports.join("");
    });
}

function compileBundle(bundleSrc) {
  // TO DO

  throw new Error("Still unimplemented");

  // var result = solc.compile(bundleSrc, 1);
  // return new Promise((resolve) => {
  //     if (!result.contracts) {
  //         throw handleErrorLines(bundleSrc, result.errors);
  //     }
  //     resolve(result.contracts);
  // });
}

function compile(entrySrcFile, destFile, opts = {}) {
  return bundleContracts(entrySrcFile)
    .then(src => {
      src = applyConstants(src, opts);
      return compileBundle(src);
    })
    .then(compiledContracts => {
      var output = "";
      output += "/* This is an autogenerated file. DO NOT EDIT MANUALLY */\n\n";

      Object.keys(compiledContracts).forEach(contractName => {
        const contract = compiledContracts[contractName];

        if (contractName[0] === ":") contractName = contractName.substr(1);
        var abi = JSON.parse(contract.interface);
        var byteCode = contract.bytecode;

        output +=
          "exports." + contractName + "Abi = " + JSON.stringify(abi) + ";\n";
        output +=
          "exports." + contractName + 'ByteCode = "0x' + byteCode + '";\n\n';
      });

      return new Promise((resolve, reject) => {
        fs.writeFile(destFile, output, err => {
          if (err) reject(err);
          else resolve();
        });
      });
    });
}

function applyConstants(src, opts) {
  Object.keys(opts).forEach(k => {
    var pattern = new RegExp("constant " + k + " = (.*);", "gm");
    var replacedText = "constant " + k + " = " + opts[k] + ";";

    // TO DO check that strings that are not addresses get stringified

    src = src.replace(pattern, replacedText);
  });
  return src;
}
