module.exports = {
  compileTo,
  compileBundled,
  bundleContractFile,
  wrapContract
};

const Promise = require("bluebird");
const solc = require("solc");
var compiler = null;

var fs, path;
if (typeof window === "undefined") {
  // NODEJS ONLY
  fs = require("fs");
  path = require("path");
}

const {
  relocateErrors,
  prependFileNameToken,
  argsToOpts
} = require("./util.js");

const {
  // sendTransaction,
  sendContractTransaction,
  sendContractConstantTransaction,
  deployContract
} = require("./rpc.js");

// FUNCTIONS

function initialize() {
  fetchLatestCompiler().catch(err => {
    console.log(err);
  });
}

function compileTo(entrySrcFile, destFile, opts = {}) {
  return bundleContractFile(entrySrcFile)
    .then(src => {
      src = applyConstants(src, opts);
      return compileBundled(src);
    })
    .then(compiledContracts => {
      var output = "";
      output +=
        "/* This is an autogenerated file. DO NOT EDIT IT MANUALLY */\n\n";

      Object.keys(compiledContracts).forEach(contractName => {
        const contract = compiledContracts[contractName];

        if (contractName[0] === ":") contractName = contractName.substr(1);
        var abi = JSON.parse(contract.interface);
        var byteCode = contract.bytecode;

        output +=
          "exports." + contractName + "Abi = " + JSON.stringify(abi) + ";\n";
        output +=
          "exports." + contractName + 'ByteCode = "0x' + byteCode + '";\n\n';
      });

      return new Promise((resolve, reject) => {
        fs.writeFile(destFile, output, err => {
          if (err) reject(err);
          else resolve();
        });
      });
    });
}

function compileBundled(bundledSource) {
  return Promise.try(() => {
    if (compiler) return;
    return initialize();
  }).then(() => {
    var result = solc.compile(bundledSource, 1);

    if (Object.keys(result.contracts).length) {
      return result.contracts;
    } else if (result.errors && result.errors.length) {
      throw relocateErrors(bundledSource, result.errors).join("\n");
    }
    throw new Error("No output was generated");
  });
}

function bundleContractFile(file, alreadyImported = {}) {
  if (typeof window !== "undefined")
    throw new Error("This functionality is only available on NodeJS");

  var src;
  if (alreadyImported[file]) return "";

  alreadyImported[file] = true;

  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function(err, sourceCode) {
      if (err) return reject(err);
      src = sourceCode;
      resolve();
    });
  })
    .then(() => {
      // resolve solidity import's
      var r = /^import "(.*)";/gm;
      var matches = src.match(r);

      src = src.replace(r, "");

      if (!matches) return src;

      return Promise.map(matches, line => {
        var r = /import "(.*)";/;
        var pendingImportedFile = r.exec(line)[1];

        pendingImportedFile = path.join(
          path.dirname(file),
          pendingImportedFile
        );

        return bundleContractFile(
          pendingImportedFile,
          alreadyImported
        ).then(content => {
          return prependFileNameToken(file) + content;
        });
      });
    })
    .then(imports => {
      return imports + src;
    });
}

function applyConstants(src, opts) {
  Object.keys(opts).forEach(k => {
    var pattern = new RegExp("constant " + k + " = (.*);", "gm");
    var replacedText = "constant " + k + " = " + opts[k] + ";";

    // TO DO check that strings (that are not addresses) get stringified

    src = src.replace(pattern, replacedText);
  });
  return src;
}

// Create a class from a contract ABI/ByteCode

function wrapContract(abi, byteCode) {
  if (!abi)
    throw new Error("The contract's Application Binary Interface is required");
  else if (typeof bytecode == "undefined")
    throw new Error("The contract's bytecode parameter is required");

  let constructorInputs = [];
  const WrappedContract = function WrappedContract(web3, address) {
    this.$web3 = web3;
    this.$address = address;
    this.$contract = this.$web3.eth.contract(abi).at(address);
    this.$abi = abi;
    this.$byteCode = byteCode;
  };

  // Populate contract functions
  abi.forEach(({ constant, name, inputs, type }) => {
    // TODO overloaded functions
    if (type === "function") {
      const constFuncCall = function() {
        const args = Array.prototype.slice.call(arguments);
        const self = this;
        var opts = argsToOpts(args, inputs);

        return sendContractConstantTransaction(
          self.$web3,
          self.$contract,
          name,
          opts
        );
      };
      if (!constant) {
        WrappedContract.prototype[name] = function() {
          const args = Array.prototype.slice.call(arguments);
          const self = this;
          var opts = argsToOpts(args, inputs);

          return sendContractTransaction(
            self.$web3,
            self.$contract,
            name,
            opts
          );
        };
      } else {
        WrappedContract.prototype[name] = constFuncCall;
      }
      WrappedContract.prototype[name].call = constFuncCall;
    } else if (type === "constructor") {
      constructorInputs = inputs;
    }
  });

  // Static generator
  WrappedContract.new = function(web3) {
    const args = Array.prototype.slice.call(arguments, 1);
    const self = this;
    var opts = argsToOpts(args, constructorInputs);

    opts.$abi = abi;
    opts.$byteCode = byteCode;

    return deployContract(web3, opts).then(contract => {
      return new self(web3, contract.address);
    });
  };
  return WrappedContract;
}

function fetchLatestCompiler() {
  return new Promise((resolve, reject) => {
    solc.loadRemoteVersion("latest", function(err, solcSnapshot) {
      if (err) {
        return reject(new Error("Unable to fetch the solc compiler"));
      }
      compiler = solcSnapshot;
      resolve();
    });
  });
}
