module.exports = {
  bundleContracts,
  applyConstants,
  compileBundle,
  compile
  // wrapContract
};

const Promise = require("bluebird");
const {
  handleErrorLines,
  prependFileNameToken,
  argsToOpts
} = require("./lib/util.js");

var fs, path;
if (typeof window === "undefined") {
  // NODEJS ONLY
  fs = require("fs");
  path = require("path");
}

function bundleContracts(file, alreadyImported = {}) {
  if (typeof window !== "undefined")
    throw new Error("This functionality is only available on NodeJS");

  var src;
  if (alreadyImported[file]) return "";

  alreadyImported[file] = true;

  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function(err, sourceCode) {
      if (err) return reject(err);
      src = sourceCode;
      resolve();
    });
  })
    .then(() => {
      // resolve solidity import's
      var r = /^import "(.*)";/gm;
      var matches = src.match(r);

      src = src.replace(r, "");

      if (!matches) return src;

      return Promise.map(matches, line => {
        var r = /import "(.*)";/;
        var pendingImportedFile = r.exec(line)[1];

        pendingImportedFile = path.join(
          path.dirname(file),
          pendingImportedFile
        );

        return bundleContracts(
          pendingImportedFile,
          alreadyImported
        ).then(content => {
          return prependFileNameToken(file) + content;
        });
      });
    })
    .then(imports => {
      return src + imports.join("");
    });
}

function compileBundle(bundleSrc) {
  // TO DO

  throw new Error("Still unimplemented");

  // var result = solc.compile(bundleSrc, 1);
  // return new Promise((resolve) => {
  //     if (!result.contracts) {
  //         throw handleErrorLines(bundleSrc, result.errors);
  //     }
  //     resolve(result.contracts);
  // });
}

function compile(entrySrcFile, destFile, opts = {}) {
  return bundleContracts(entrySrcFile)
    .then(src => {
      src = applyConstants(src, opts);
      return compileBundle(src);
    })
    .then(compiledContracts => {
      var output = "";
      output += "/* This is an autogenerated file. DO NOT EDIT MANUALLY */\n\n";

      Object.keys(compiledContracts).forEach(contractName => {
        const contract = compiledContracts[contractName];

        if (contractName[0] === ":") contractName = contractName.substr(1);
        var abi = JSON.parse(contract.interface);
        var byteCode = contract.bytecode;

        output +=
          "exports." + contractName + "Abi = " + JSON.stringify(abi) + ";\n";
        output +=
          "exports." + contractName + 'ByteCode = "0x' + byteCode + '";\n\n';
      });

      return new Promise((resolve, reject) => {
        fs.writeFile(destFile, output, err => {
          if (err) reject(err);
          else resolve();
        });
      });
    });
}

function applyConstants(src, opts) {
  Object.keys(opts).forEach(k => {
    var pattern = new RegExp("constant " + k + " = (.*);", "gm");
    var replacedText = "constant " + k + " = " + opts[k] + ";";

    // TO DO check that strings that are not addresses get stringified

    src = src.replace(pattern, replacedText);
  });
  return src;
}

// Create a class from a contract ABI/ByteCode

// function wrapContract(abi, byteCode) {
//   if (!abi) throw new Error("The contract's Application Binary Interface is required");
//   else if (typeof bytecode == "undefined") throw new Error("The contract's bytecode parameter is required");

//   let constructorInputs = [];
//   const WrappedContract = function WrappedContract(web3, address) {
//     this.$web3 = web3;
//     this.$address = address;
//     this.$contract = this.$web3.eth.contract(abi).at(address);
//     this.$abi = abi;
//     this.$byteCode = byteCode;
//   }

//   // Populate contract functions
//   abi.forEach(({ constant, name, inputs, type }) => {
//     // TODO overloaded functions
//     if (type === "function") {
//       const constFuncCall = function () {
//         const args = Array.prototype.slice.call(arguments);
//         const self = this;
//         var opts = argsToOpts(args, inputs);

//         return sendContractConstTx(
//           self.$web3,
//           self.$contract,
//           name,
//           opts);
//       }
//       if (!constant) {
//         WrappedContract.prototype[name] = function () {
//           const args = Array.prototype.slice.call(arguments);
//           const self = this;
//           var opts = argsToOpts(args, inputs);

//           return sendContractTx(
//             self.$web3,
//             self.$contract,
//             name,
//             opts);
//         };
//       }
//       else {
//         WrappedContract.prototype[name] = constFuncCall;
//       }
//       WrappedContract.prototype[name].call = constFuncCall;
//     }
//     else if (type === "constructor") {
//       constructorInputs = inputs;
//     }
//   });

//   // Static generator
//   WrappedContract.new = function (web3) {
//     const args = Array.prototype.slice.call(arguments, 1);
//     const self = this;
//     var opts = argsToOpts(args, constructorInputs);

//     opts.$abi = abi;
//     opts.$byteCode = byteCode;

//     return deploy(web3, opts).then(contract => {
//       return new self(web3, contract.address);
//     });
//   };
//   return WrappedContract;
// }
