module.exports = {
  compileTo,
  compileBundled,
  bundleContractFile
};

const Promise = require("bluebird");
var solc = null;
var compiler = null;

var fs, path;
// NODEJS ONLY
if (typeof window === "undefined") {
  // NOTE: This is a hack to prevent webpack or Next.js from
  // attempting to bundle these modules
  const solcRequire = 'require("solc")';
  const fsRequire = 'require("fs")';
  const pathRequire = 'require("path")';

  solc = eval(solcRequire);
  fs = eval(fsRequire);
  path = eval(pathRequire);
}

const { relocateErrors, prependFileNameToken } = require("./util.js");

// FUNCTIONS

function initialize() {
  return fetchLatestCompiler().catch(err => {
    console.log(err);
  });
}

function compileTo(entrySrcFile, destFile, opts = {}) {
  if (!fs)
    throw new Error("compileTo() is only available on NodeJS environments");

  return bundleContractFile(entrySrcFile)
    .then(src => {
      src = applyConstants(src, opts);
      return compileBundled(src);
    })
    .then(compiledContracts => {
      var output =
        "/* This is an autogenerated file. DO NOT EDIT IT MANUALLY */\n\n";
      output += "module.exports = {";

      Object.keys(compiledContracts).forEach(contractName => {
        const contract = compiledContracts[contractName];

        if (contractName[0] === ":") contractName = contractName.substr(1);
        var abi = JSON.parse(contract.interface);
        var byteCode = contract.bytecode;

        output += `\n  ${contractName}: {
    abi: ${JSON.stringify(abi)},
    byteCode: "0x${byteCode}"
  },\n`;
      });
      output += "}\n\n";

      return new Promise((resolve, reject) => {
        fs.writeFile(destFile, output, err => {
          if (err) reject(err);
          else resolve();
        });
      });
    });
}

function compileBundled(bundledSource) {
  if (!fs)
    throw new Error(
      "compileBundled() is only available on NodeJS environments"
    );

  return Promise.try(() => {
    if (compiler) return;
    return initialize();
  }).then(() => {
    var result = solc.compile(bundledSource, 1);

    if (Object.keys(result.contracts).length) {
      return result.contracts;
    } else if (result.errors && result.errors.length) {
      throw relocateErrors(bundledSource, result.errors).join("\n");
    }
    throw new Error("No output was generated");
  });
}

function bundleContractFile(file, alreadyImported = {}) {
  if (!fs)
    throw new Error(
      "bundleContractFile() is only available on NodeJS environments"
    );

  var fileSource = "";
  if (alreadyImported[file]) return "";

  alreadyImported[file] = true;

  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function(err, sourceCode) {
      if (err) return reject(err);
      fileSource = sourceCode;
      resolve();
    });
  })
    .then(() => {
      // resolve solidity import's
      var r = /^import "(.*)";/gm;
      var matches = fileSource.match(r);

      fileSource = fileSource.replace(r, "");

      if (!matches) return [];

      return Promise.map(matches, line => {
        var r = /import "(.*)";/;
        var pendingImportedFile = r.exec(line)[1];

        pendingImportedFile = path.join(
          path.dirname(file),
          pendingImportedFile
        );

        return bundleContractFile(pendingImportedFile, alreadyImported);
      });
    })
    .then(imports => {
      return (imports || []).join("") + prependFileNameToken(file) + fileSource;
    });
}

function applyConstants(src, opts) {
  Object.keys(opts).forEach(k => {
    var pattern = new RegExp("constant " + k + " = (.*);", "gm");
    var replacedText = "constant " + k + " = " + opts[k] + ";";

    // TO DO check that strings (that are not addresses) get stringified

    src = src.replace(pattern, replacedText);
  });
  return src;
}

function fetchLatestCompiler() {
  return new Promise((resolve, reject) => {
    solc.loadRemoteVersion("latest", function(err, solcSnapshot) {
      if (err) {
        return reject(new Error("Unable to fetch the solc compiler"));
      }
      compiler = solcSnapshot;
      resolve();
    });
  });
}
