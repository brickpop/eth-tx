module.exports = {
  compileTo,
  compileBundled,
  bundleContractFile,
  wrapContract
};

const Promise = require("bluebird");
const solc = require("solc");
var compiler = null;

var fs, path;
if (typeof window === "undefined") {
  // NODEJS ONLY
  fs = require("fs");
  path = require("path");
}

const {
  relocateErrors,
  prependFileNameToken,
  argsToOpts
} = require("./util.js");

const {
  getCurrentWeb3,
  // sendTransaction,
  sendContractTransaction,
  sendContractConstantTransaction,
  deployContract
} = require("./rpc.js");

// FUNCTIONS

function initialize() {
  fetchLatestCompiler().catch(err => {
    console.log(err);
  });
}

function compileTo(entrySrcFile, destFile, opts = {}) {
  return bundleContractFile(entrySrcFile)
    .then(src => {
      src = applyConstants(src, opts);
      return compileBundled(src);
    })
    .then(compiledContracts => {
      var output =
        "/* This is an autogenerated file. DO NOT EDIT IT MANUALLY */\n\n";
      output += "module.exports = {";

      Object.keys(compiledContracts).forEach(contractName => {
        const contract = compiledContracts[contractName];

        if (contractName[0] === ":") contractName = contractName.substr(1);
        var abi = JSON.parse(contract.interface);
        var byteCode = contract.bytecode;

        output += `\n  ${contractName}: {
    abi: ${JSON.stringify(abi)},
    byteCode: "0x${byteCode}"
  },\n`;
      });
      output += "}\n\n";

      return new Promise((resolve, reject) => {
        fs.writeFile(destFile, output, err => {
          if (err) reject(err);
          else resolve();
        });
      });
    });
}

function compileBundled(bundledSource) {
  return Promise.try(() => {
    if (compiler) return;
    return initialize();
  }).then(() => {
    var result = solc.compile(bundledSource, 1);

    if (Object.keys(result.contracts).length) {
      return result.contracts;
    } else if (result.errors && result.errors.length) {
      throw relocateErrors(bundledSource, result.errors).join("\n");
    }
    throw new Error("No output was generated");
  });
}

function bundleContractFile(file, alreadyImported = {}) {
  if (typeof window !== "undefined")
    throw new Error("This functionality is only available on NodeJS");

  var fileSource = "";
  if (alreadyImported[file]) return "";

  alreadyImported[file] = true;

  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function(err, sourceCode) {
      if (err) return reject(err);
      fileSource = sourceCode;
      resolve();
    });
  })
    .then(() => {
      // resolve solidity import's
      var r = /^import "(.*)";/gm;
      var matches = fileSource.match(r);

      fileSource = fileSource.replace(r, "");

      if (!matches) return [];

      return Promise.map(matches, line => {
        var r = /import "(.*)";/;
        var pendingImportedFile = r.exec(line)[1];

        pendingImportedFile = path.join(
          path.dirname(file),
          pendingImportedFile
        );

        return bundleContractFile(pendingImportedFile, alreadyImported);
      });
    })
    .then(imports => {
      return (imports || []).join("") + prependFileNameToken(file) + fileSource;
    });
}

function applyConstants(src, opts) {
  Object.keys(opts).forEach(k => {
    var pattern = new RegExp("constant " + k + " = (.*);", "gm");
    var replacedText = "constant " + k + " = " + opts[k] + ";";

    // TO DO check that strings (that are not addresses) get stringified

    src = src.replace(pattern, replacedText);
  });
  return src;
}

// Create a class from a contract ABI/ByteCode

function wrapContract(abi, byteCode) {
  if (!abi)
    throw new Error("The contract's Application Binary Interface is required");
  else if (typeof byteCode == "undefined")
    throw new Error("The contract's bytecode parameter is required");

  let constructorInputs = [];
  const WrappedContract = function WrappedContract(address) {
    const web3 = getCurrentWeb3();

    if (web3.version[0] == "0") {
      // version 0.x.x
      this.$contract = web3.eth.contract(abi).at(address);
    } else {
      // newer
      this.$contract = new web3.eth.Contract(abi, address);
    }
    this.$address = address;
    this.$abi = abi;
    this.$byteCode = byteCode;
  };

  // Populate contract functions
  abi.forEach(({ constant, name, inputs, type }) => {
    // TODO overloaded functions
    if (type === "function") {
      if (!constant) {
        WrappedContract.prototype[name] = function() {
          const args = Array.prototype.slice.call(arguments);
          var opts = argsToOpts(args, inputs);

          return sendContractTransaction(this.$contract, this.$abi, name, opts);
        };
      } else {
        WrappedContract.prototype[name] = function() {
          const args = Array.prototype.slice.call(arguments);
          var opts = argsToOpts(args, inputs);

          return sendContractConstantTransaction(
            this.$contract,
            this.$abi,
            name,
            opts
          );
        };
      }
      // all
      WrappedContract.prototype[name].call = function() {
        const args = Array.prototype.slice.call(arguments);
        var opts = argsToOpts(args, inputs);

        return sendContractConstantTransaction(
          this.$contract,
          this.$abi,
          name,
          opts
        );
      };
    } else if (type === "constructor") {
      constructorInputs = inputs;
    }
  });

  // Static generator
  WrappedContract.new = function() {
    const args = Array.prototype.slice.call(arguments, 0);
    const self = this;
    var opts = argsToOpts(args, constructorInputs);

    opts.$abi = abi;
    opts.$byteCode = byteCode;

    return deployContract(opts).then(contract => {
      if (!contract) throw new Error("Empty contract");

      return new self(
        (contract.options && contract.options.address) ||
          contract._address ||
          contract.address
      );
    });
  };
  return WrappedContract;
}

function fetchLatestCompiler() {
  return new Promise((resolve, reject) => {
    solc.loadRemoteVersion("latest", function(err, solcSnapshot) {
      if (err) {
        return reject(new Error("Unable to fetch the solc compiler"));
      }
      compiler = solcSnapshot;
      resolve();
    });
  });
}
