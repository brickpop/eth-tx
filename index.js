/*
This library is a combination based on the work of Jordi Baylina
- https://github.com/jbaylina/ethconnector
- https://github.com/jbaylina/runethtx
*/

const Promise = require("bluebird");
const Web3 = require("web3");
const TestRPC = require("ethereumjs-testrpc");

var fs, path;
if (typeof window === "undefined") {
  // NODEJS ONLY
  fs = require("fs");
  path = require("path");
}

// Local State

var connected = false;
var web3 = new Web3();
var gasLimit = 4000000;
var gasPrice = web3.toWei(0.00000006);
var accounts = [];

module.exports = {
  connect,
  bundleContracts,
  applyConstants,
  compile,
  compileBundle,
  deployContract,
  delay

  // deploy,
  // sendContractTx,
  // sendTx,
  // getBalance,
  // getTransactionReceipt,
  // getBlock,
  // asyncfunc,
  // generateClass
};

// CONNECTION

function connect(provider = "testrpc", opts = {}) {
  if (provider.toUpperCase() === "TESTRPC") {
    web3.setProvider(TestRPC.provider(opts));
  } else {
    web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
  }

  if (opts.gasLimit) gasLimit = opts.gasLimit;
  if (opts.gasPrice) gasPrice = opts.gasPrice;

  return new Promise((resolve, reject) => {
    web3.eth.getAccounts(function(err, accountList) {
      if (err) return reject(err);
      accounts = accountList;

      connected = true;
      resolve();
    });
  });
}

// CONTRACT CODE MANAGEMENT

function bundleContracts(file, alreadyImported = {}) {
  if (typeof window !== "undefined")
    throw new Error("This functionality is only available on NodeJS");

  var src;
  if (alreadyImported[file]) return "";

  alreadyImported[file] = true;

  return new Promise((resolve, reject) => {
    fs.readFile(file, "utf8", function(err, sourceCode) {
      if (err) return reject(err);
      src = sourceCode;
      resolve();
    });
  })
    .then(() => {
      // resolve solidity import's
      var r = /^import "(.*)";/gm;
      var matches = src.match(r);

      src = src.replace(r, "");

      if (!matches) return src;

      return Promise.map(matches, line => {
        var r = /import "(.*)";/;
        var pendingImportedFile = r.exec(line)[1];

        pendingImportedFile = path.join(
          path.dirname(file),
          pendingImportedFile
        );

        return bundleContracts(
          pendingImportedFile,
          alreadyImported
        ).then(content => {
          return "\n//File: " + file + "\n" + content;
        });
      });
    })
    .then(imports => {
      return src + imports.join("");
    });
}

function applyConstants(src, opts) {
  Object.keys(opts).forEach(k => {
    var pattern = new RegExp("constant " + k + " = (.*);", "gm");
    var replacedText = "constant " + k + " = " + opts[k] + ";";

    // TO DO check that strings that are not addresses get stringified

    src = src.replace(pattern, replacedText);
  });
  return src;
}

function compileBundle(bundleSrc) {
  // TO DO

  throw new Error("Still unimplemented");

  // var result = solc.compile(bundleSrc, 1);
  // return new Promise((resolve) => {
  //     if (!result.contracts) {
  //         throw locateErrorLines(bundleSrc, result.errors);
  //     }
  //     resolve(result.contracts);
  // });
}

function compile(entrySrcFile, destFile, opts = {}) {
  return bundleContracts(entrySrcFile)
    .then(src => {
      src = applyConstants(src, opts);
      return compileBundle(src);
    })
    .then(compiledContracts => {
      var output = "";
      output += "/* This is an autogenerated file. DO NOT EDIT MANUALLY */\n\n";

      Object.keys(compiledContracts).forEach(contractName => {
        const contract = compiledContracts[contractName];

        if (contractName[0] === ":") contractName = contractName.substr(1);
        var abi = JSON.parse(contract.interface);
        var byteCode = contract.bytecode;

        output +=
          "exports." + contractName + "Abi = " + JSON.stringify(abi) + ";\n";
        output +=
          "exports." + contractName + 'ByteCode = "0x' + byteCode + '";\n\n';
      });

      return new Promise((resolve, reject) => {
        fs.writeFile(destFile, output, err => {
          if (err) reject(err);
          else resolve();
        });
      });
    });
}

function deployContract(abi, codeData, account, value) {
  if (!connected)
    throw new Error(
      "You need to initialize eth-tx before you can deploy a contract"
    );

  var deployArgs = Array.prototype.slice.call(
    arguments,
    4,
    arguments.length - 1
  );

  if (typeof abi == "string") abi = JSON.parse(abi);
  if (typeof account == "number") account = accounts[account];

  deployArgs.push({
    from: account,
    value,
    data: codeData,
    gas: gasLimit,
    gasPrice
  });

  return new Promise((resolve, reject) => {
    deployArgs.push(function(err, contract) {
      // eventual callback
      if (err) return reject(err);
      else if (contract && contract.address) {
        resolve(contract);
      }
    });

    var contract = web3.eth.contract(abi);
    contract.new.apply(contract, deployArgs);
  });
}

function delay(secs) {
  return rpcSend("evm_mine")
    .then(() => rpcSend("evm_increaseTime", [secs]))
    .then(() => rpcSend("evm_mine"));
}

// UTILITY FUNCTIONS

// CALL a low level RPC
function rpcSend(method, params) {
  if (!connected)
    return Promise.reject(
      new Error(
        "You need to initialize eth-tx before you can deploy a contract"
      )
    );

  return new Promise((resolve, reject) => {
    web3.currentProvider.sendAsync(
      {
        jsonrpc: "2.0",
        method,
        params: params || [],
        id: new Date().getTime()
      },
      err => {
        if (err) reject(err);
        else resolve();
      }
    );
  });
}

// Find the original file (before bundling) that originated every one of the errors found

function locateErrorLines(bundledContractSrc, errors) {
  var lines = bundledContractSrc.split("\n");
  if (!bundledContractSrc || !errors || !errors.length) return [];

  errors.forEach((error, idx) => {
    var rErrPos = new RegExp(":([0-9]+):([0-9]+):");
    var errPos = rErrPos.exec(error);
    var lineNum = errPos ? parseInt(errPos[1]) - 1 : -1;
    var offset = 1;
    var filePattern = new RegExp("//File: (.*)", "");
    var fileInfo;

    while (offset <= lineNum) {
      fileInfo = filePattern.exec(lines[lineNum - offset]);
      if (fileInfo) {
        errors[idx] = error.replace(
          rErrPos,
          fileInfo[1] + " :" + offset + ":" + errPos[2] + ":"
        );
        break;
      }
      offset++;
    }
  });
  return errors;
}
